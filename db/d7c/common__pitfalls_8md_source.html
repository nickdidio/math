<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: doxygen/contributor_help_pages/common_pitfalls.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.1.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('db/d7c/common__pitfalls_8md.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doxygen/contributor_help_pages/common_pitfalls.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../db/d7c/common__pitfalls_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;## Common Pitfalls {#common_pitfalls}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;### Eigen Expressions (and handling argument types with SFINAE)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;An additional complexity of the Math library is that `vector`, `row_vector`,</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;and `matrix` do not map to just templated `Eigen::Matrix` types, they can</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;also map to a variety of Eigen expressions.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;For instance, in the following code, the result `c` is not a vector, but</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;a vector-like type representing the not-yet-calculated sum of `a` and `b`:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;```cpp</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Eigen::VectorXd a(5);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;Eigen::VectorXd b(5);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;// auto is actually a</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;// Eigen::CwiseBinaryOp&lt;Eigen::internal::scalar_sum_op&lt;double, double&gt;, const Eigen::Matrix&lt;double, -1, 1&gt;, const Eigen::Matrix&lt;double, -1, 1&gt;&gt;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;auto c = a + b;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;```</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;Similarly, there are other representations of vectors and matrices</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;yet discussed, in particular matrices stored in Math&#39;s special arena</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;memory or matrices stored on a GPU. In either case, it is expedient</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;to not write explicit overloads for all the different types that a</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;function might accept, but limit them with template meta-programs.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;For instance, if only base Eigen types are allowed, then a function</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;that takes vector types could be defined as follows:</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;```cpp</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;T norm(const Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;&amp;);</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;```</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;A typical problem with a function like this is that `norm` can</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;similarly be defined for a row vector (and the implementation is</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;the same). In this case there are two signatures:</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;```cpp</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;T norm(const Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;&amp;);</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;T norm(const Eigen::Matrix&lt;T, 1, Eigen::Dynamic&gt;&amp;);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;```</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;The simple solution to this problem is to move to a fully templated signature:</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;```cpp</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;return_type_t&lt;T&gt; norm(const T&amp;);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;```</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;The immediate problem here is what if there actually are differences in</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;the implementations? The most common situation is that encountered when</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;there is one generic templated implementation that works with any autodiff</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;type, and then a second faster overload that only works with a specific</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;autodiff type.</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;There can easily be ambiguities between the two function signatures. The</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;previous examples took advantage of simple overloads. The more general solution</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;are template metaprograms that additionally make use of C++ substitution failure</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;is not an error (SFINAE) semantics. For instance, for the norm function above,</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;SFINAE could be used to limit one signature to work with reverse</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;mode autodiff types and one to work with anything else:</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;```cpp</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;template &lt;typename T,</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;          require_st_var&lt;T&gt;* = nullptr&gt;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;return_type_t&lt;T&gt; norm(const T&amp;);</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;template &lt;typename T,</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;          require_not_st_var&lt;T&gt;* = nullptr&gt;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;return_type_t&lt;T&gt; norm(const T&amp;);</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;```</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;SFINAE should be thought of as filters on what functions are visible to the</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;compiler when it does name lookup for a specific function. `require_st_var`</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;should be read &quot;require the scalar type of the argument to be a `var`&quot;. The</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;meta-program `require_st_var&lt;T&gt;` will evaluate to a valid type if the scalar</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;type of `T` is a `var`. If the scalar type of `T` is not a `var`, then</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;`require_st_var&lt;T&gt;` does not evaluate to a valid type, and it is not possible</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;to do template substitution on this signature, and the compiler treats it as</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;if it does not exist. This is how SFINAE (substitution failure is not an error)</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;works. Because the substitution does not work, the signature is ignored.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;This is all built based on C++&#39;s</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;[std::enable_if](https://en.cppreference.com/w/cpp/types/enable_if)</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;template metaprogram.</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;Again, there are many ways to solve a problem in C++. In particular there</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;are cases where simple overloads or template specializations can achieve the</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;same thing as the SFINAE template meta-programs. Unless there is a specific</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;reason though, new functions in Math should use the SFINAE meta-programs to</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;handle different implementations. These are tested to work with the broad</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;set of C++ types that the relatively compact set of Stan types map to.</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;The vast majority of the SFINAE template meta-programs in Math are special</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;to Stan or Math. Documentation can be found in the</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;[Doxygen](https://mc-stan.org/math/) docs. If functionality is not available,</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;it new meta-programs should be added.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;### Reference types</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;Any time a function takes a vector or matrix type, it needs to be able</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;to also handle an expression that evaluates to that type. Some expressions</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;can be expensive to evaluate, so each expression should be evaluated only once.</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;If the results of an expression is needed in multiple places, they should be saved.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;Eigen expressions can result from many places, including arithmetic operations,</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;a matrix multiply, a sum, or a variety of other things. Some expressions are cheap</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;to evaluate, any of the Eigen views qualify here (transpose, block access, segment, etc).</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;In this case, evaluating the expression is not necessary -- it would only lead to another</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;allocate and copy.</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;The Math function `to_ref` is a solution for this. For a vector</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;or matrix variable `x`, `to_ref(x)` returns an Eigen reference to the</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;input variable `x`. If `x` was an expensive expression, it will be evaluated.</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;If it was a cheap expression, the reference type won&#39;t evaluate. If it</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;isn&#39;t an Eigen type, the `to_ref` just forwards.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;```cpp</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;template &lt;typename T,</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;          require_eigen_t&lt;T&gt;* = nullptr&gt;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;auto myfunc(const T&amp; x) {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  const auto&amp; x_ref = to_ref(x);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;}</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;```</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;### Holders</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;If a function returns an Eigen expression, it may be necessary to use</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;the `make_holder` utility.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;Returning expressions is tricky because the expression may have a longer</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;lifetime than the objects it operates on. For instance, returning an</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;expression on a local variable leads to this situation:</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;```cpp</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;auto add_zero(const T&amp; a) {</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  Eigen::VectorXd b = Eigen::VectorXd(a.size());</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  return a + b;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;```</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;Because the return type of this function is `auto`, it is possible</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;that it returns an Eigen expression.</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;The following code will segfault on the construction of `c` because</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;by this time the temporary `b` will have been destructed.</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;```</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;Eigen::VectorXd a(5);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;Eigen::VectorXd c = add_zero(a);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;```</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;`make_holder` can be used to extend the lifetime of `b` so that it matches</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;the expression it is used in.</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;```cpp</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;template &lt;typename T&gt;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;auto add_zero(const T&amp; a) {</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  Eigen::VectorXd b = Eigen::VectorXd(a.size());</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  return make_holder([](const auto&amp; l, const auto&amp; r) { return l + r; }, a, std::move(b));</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;}</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;```</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;Returning expressions is an advanced feature and it is easy to make</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;mistakes. In this regard, it is simplest to start development not</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;returning expressions (in this case holders are unnecessary), and only</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;add expression return types later.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;It is always possible to return a non-expression type by evaluating</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;the Eigen expression. For convenience, there is an `eval` function</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;in Math that will evaluate Eigen expressions and forward anything</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;else. This is convenient because it works on non-Eigen types as well</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;(as compared to the built in `.eval()` member function on Eigen</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;types).</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;The implementation of `make_holder` is</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;[here](https://github.com/stan-dev/math/blob/develop/stan/math/prim/meta/holder.hpp).</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;### Move Semantics</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;In general, Stan math does not use move semantics very often. This is because of our arena allocator. Move semantics generally work as</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;```cpp</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;class my_big_type {</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  double* m_data;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  explicit my_big_type(size_t N) m_data(static_cast&lt;double*&gt;(malloc(N))) {}</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;  // Standard copy constructor</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  my_big_type(const my_big_type&amp; other) m_data(static_cast&lt;double*&gt;(malloc(N))) {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    std::copy(other.m_data, this-&gt;m_data);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  }</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  // Standard move constructor</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  my_big_type(my_big_type&amp;&amp; other) m_data(other.m_data) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    other.m_data = nullptr;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  }</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;};</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;```</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;We can see in the above that the standard style of a move (the constructor taking an rvalue reference) is to copy the pointer and then null out the original pointer. But in Stan, particularly for reverse mode, we need to keep memory around even if  it&#39;s only a temporary for when we call the gradient calculations in the reverse pass. And since memory for reverse mode is stored in our arena allocator no copying happens in the first place.</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;When working with arithmetic types, keep in mind that moving Scalars is often less optimal than simply taking their copy. For instance, Stan&#39;s `var` type is a PIMPL implementation, so it simply holds a pointer of size 8 bytes. A `double` is also 8 bytes which just so happens to fit exactly in a [word](https://en.wikipedia.org/wiki/Word_(computer_architecture)) of most modern CPUs. While a reference to a double is also 8 bytes, unless the function is inlined by the compiler, the computer will have to place the reference into cache, then go fetch the value that is being referenced which now takes up two words instead of one!</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;The general rules to follow for passing values to a function are:</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;1. If a type is smaller than two words (16 bytes), pass it by value</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;2. If you are writing a function for reverse mode, pass values by `const&amp;`</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;3. In prim, if you are confident and working with larger types, use perfect forwarding to pass values that can be moved from. Otherwise simply pass values by `const&amp;`.</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;### Copying non-arena variables to lambdas used in the reverse pass (`make_callback_ptr`)</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;When possible, non-arena variables should be copied to the arena to be</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;used in the reverse pass. The two tools for that are `arena_t&lt;T&gt;` and</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;`to_arena`.</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;When these tools do not work, there is `make_callback_ptr(x)`.</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;`make_callback_ptr(x)` constructs a copy of the argument `x` and returns</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;a pointer to that copy. The copy of `x` will only be destructed when the</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;enclosing `recover_memory` is called.</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;The pointer is cheap to copy around and is safe to copy into lambdas for</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;`reverse_pass_callback` and `make_callback_var`.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;As an example, see the implementation of `mdivide_left`</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;[here](https://github.com/stan-dev/math/blob/develop/stan/math/rev/fun/mdivide_left.hpp)</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;where `make_callback_ptr()` is used to save the result of an Eigen</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;Householder QR decomposition for use in the reverse pass.</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;The implementation is in</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;[stan/math/rev/core/chainable_object.hpp](https://github.com/stan-dev/math/blob/develop/stan/math/rev/core/chainable_object.hpp)</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;### Returning arena types</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;Suppose we have a function such as</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;```cpp</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;/**</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160; * Returns the dot product of a vector of var with itself.</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160; *</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160; * @tparam EigVec An Eigen type with compile time rows or columns equal to 1 and a scalar var type.</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160; * @param[in] v Vector.</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160; * @return Dot product of the vector with itself.</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160; */</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;template &lt;typename EigVec, require_eigen_vt&lt;is_var, EigVec&gt;* = nullptr&gt;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;inline var cool_fun(const EigVec&amp; v) {</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  arena_t&lt;EigVec&gt; arena_v(v);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  arena_t&lt;EigVec&gt; res = arena_v.val().array() * arena_v.val().array();</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  reverse_pass_callback([res, arena_v]() mutable {</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    arena_v.adj().array() += (2.0 * res.adj().array()) * arena_v.val().array();</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  });</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  return res;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;}</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;```</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;There&#39;s a deceptive problem in this return! We are returning back an `arena_matrix&lt;EigVec&gt;`, which is an Eigen matrix completely existing on our arena allocator. The problem here is that we&#39;ve also passed `res` to our callback, and now suppose a user does something like the following.</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;```cpp</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;Eigen::Matrix&lt;var, -1, 1&gt; x = Eigen::Matrix&lt;double, -1, 1&gt;::Random(5);</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;auto innocent_return = cool_fun(x);</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;innocent_return.coeffRef(3) = var(3.0);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;auto other_return = cool_fun2(innocent_return);</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;grad();</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;```</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;Now `res` is `innocent_return` and we&#39;ve changed one of the elements of `innocent_return`, but that is also going to change the element of `res` which is being used in our reverse pass callback! The answer for this is simple but sadly requires a copy.</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;```cpp</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;template &lt;typename EigVec, require_eigen_vt&lt;is_var, EigVec&gt;* = nullptr&gt;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;inline var cool_fun(const EigVec&amp; v) {</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  arena_t&lt;EigVec&gt; arena_v(v);</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  arena_t&lt;EigVec&gt; res = arena_v.val().array() * arena_v.val().array();</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  reverse_pass_callback([res, arena_v]() mutable {</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    arena_v.adj().array() += (2.0 * res.adj().array()) * arena_v.val().array();</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  });</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  return plain_type_t&lt;EigVec&gt;(res);</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;}</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;```</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;we make a deep copy of the return whose inner `vari` will not be the same but the `var` will produce a new copy of the pointer to the `vari`. Now the user code above will be protected and it is safe for them to assign to individual elements of the `auto` returned matrix.</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;### Const correctness, reverse mode autodiff, and arena types</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;In general, it&#39;s good to have arithmetic and integral types as `const`, for instance pulling out the size of a vector to reuse later such as `const size_t x_size = x.size();`. However vars, and anything that can contain a var should not be `const`. This is because in reverse mode we want to update the value of the `adj_` inside of the var, which requires that it is non-const.</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;## Handy tricks</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;### `forward_as`</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;In functions such as [Stan&#39;s distributions](https://github.com/stan-dev/math/blob/1bf96579de5ca3d06eafbc2eccffb228565b4607/stan/math/prim/prob/exponential_cdf.hpp#L64) you will see code which uses a little function called `forward_as&lt;&gt;` inside of if statements whose values are known at compile time. In the following code, `one_m_exp` can be either an Eigen vector type or a scalar.</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;```cpp</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;T_partials_return cdf(1.0);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;if (is_vector&lt;T_y&gt;::value || is_vector&lt;T_inv_scale&gt;::value) {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  cdf = forward_as&lt;T_partials_array&gt;(one_m_exp).prod();</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;} else {</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  cdf = forward_as&lt;T_partials_return&gt;(one_m_exp);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;}</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;```</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;Do note that in the above, since the if statements values are known at compile time, the compiler will always remove the unused side of the `if` during the dead code elimination pass. But the dead code elimination pass does not happen until all the code is instantiated and verified as compilable. So `forward_as()` exists to trick the compiler into believing both sides of the `if` will compile. If we used C++17, the above would become</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;```cpp</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;T_partials_return cdf(1.0);</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;if constexpr (is_vector&lt;T_y&gt;::value || is_vector&lt;T_inv_scale&gt;::value) {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  cdf = one_m_exp.prod();</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;} else {</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  cdf = one_m_exp;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;}</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;```</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;Where [`if constexpr`](https://en.cppreference.com/w/cpp/language/if) is run before any tests are done to verify the code can be compiled.</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;Using `forward_as&lt;TheTypeIWant&gt;(the_obj)` will, when `the_obj` matches the type the user passes, simply pass back a reference to `the_obj`. But when `TheTypeIWant` and `the_obj` have different types it will throw a runtime error. This function should only be used inside of `if` statements like the above where the conditionals of the `if` are known at compile time.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d7c/common__pitfalls_8md.html">common_pitfalls.md</a></li>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
